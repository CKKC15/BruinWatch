Okay. Let's get started, everyone. I wonder if we can keep a door open or something open because it gets really warm in here. But anyway, let's get started. Today we're going to be talking about assembly basics, but we're also going to do some reviewing of integers. I just want to start with some administrative announcements. Slido is open. We're going to have round two of C puzzles. They're a little bit harder this time because you've also had some more practice during discussion. We'll do that. Please open up the slido, same link, same QR code for the entire quarter. As I mentioned before, you can use the slido if you're studying and watching the video of the lecture, you can ask questions and the course staff and I check it. Slido, everybody has slide open? Individual work deadlines. The TAs explained to me that there was some confusion about the difference between individual and group work for the weekly assignments. The individual work is your attempt at completing all of the problems. For the discussion worksheet. It doesn't have to be perfect, but you have to try to complete all of them. That is the individual discussion work that you have to do. I mean, it's officially due Friday, but you have a grace period until Sunday and that just says, try to get it done by Friday, but if you need extra time, it's totally fine. That's what we mean by the grace period. Don't bank on the grace period because after the grace period, you are at the mercy of your TAs. What I mean by that is you can email your TAs and if they will process the assignment for you before the solutions are posted, fine, but the solutions are going to be posted on Monday mornings. So that's going to be a concern if you want to play roulette that way. Try to get it in before Sunday evening. Data Lab Lab one is released and you have a grace period on Data Lab one. So that's due next Friday the 18th and you have until Sunday the grace period. We're going to have a Data lab workshop led by the LAs and the two LAs that are leading it are Randy and Ryvic and that's going to be on Zoom and it should be recorded. Okay. Does anybody have administrative questions now? I'm going to check the slido. Also, I'm using the time checking the slido, giving you a chance to be quiet. The solutions to the puzzles from April 3rd are already posted on the annotated lecture notes. Oh, no, I think I posted them on Piazza, but I'm going to talk about why the solutions are what they are right now. The solutions are posted, but we're going to talk about them now. Data lab. The point of the Data Lab is to give you the opportunity to get comfortable with bit level implementations and C. It's very similar to Lab zero. We're going to talk about the solution today. The way that the problems are formatted are exactly as in Lab zero. You're given some required function and you have to use low level operators. You're only allowed to use bitwise or and exclusive or left and right shift plus bitwise ts and logical naughts. It actually says this on the bits dot C file and all you have to upload is bits dot C. You cannot use any control constructs like if do while, for switch, You can't use any macros, you cannot define any additional functions, call any functions, or use any other operations such as logical and logical or subtraction, or the question mark colon operator. You can't use those. You cannot use any form of casting and you cannot use any other data types except for ints. There's also a restriction on the constants that you can use also, which is in the bits dot C file. One example of what it looks like for lab one is just this function get byte, which tells you which byte you're given an integer and it asks you to return the nth byte of that integer. Today we're going to talk about lab zero, the function that you have to write for lab zero, which has a very similar type of function exercised in it. Advice for lab one, use the alias cs 30 threes dot dot ev You can also log directly into Linux servers, but the CS 33 will log you into different ones. A good suggestion for exams is to try to solve the problems on small examples by hand because that will help you for exams if you have to actually answer those. Also, it's good for you to be able to trace through your code and be able to write your code on paper because during the midterm, you might have a similar exercise writing a similar problem from the Datab on the midterm by hand. For debugging, you can use print F, but just make sure you delete them before you turn it in because you will get problems when you actually run it to check for correctness. GDB will be necessary the next lab and the LAs, I believe, will hold a workshop on using GDB for the boom lab. But you can use GDB for this if you want, but print F is probably sufficient. I wanted to clarify now what the group work is because I know there was some confusion about that. The group work is whatever you and your learning pod can finish during discussion, that's sufficient. You just upload some effort on some problem that you completed during discussion. For your check in, if you and your group know how to do a problem, you just need to present it to a member of the course staff. If you need help, you sitting with a member of the core staff, getting help is also a check in. If you do either of those things, you will get credit for the check in part for the in lab portion, and then you just have to upload whatever you worked on during discussion, and that's your group work. I don't know if you noticed this on gradescope. One person can actually submit for the entire team. You can do a group submission and you just put the rest of your pod into that submission on gradescope. Okay. We'll have the Week two discussion group check in, and that's how it'll work. It'll be more organized now because the learning pubs hopefully will be finalized by this Friday. Okay. Where are lectures posted? Somebody just asked. It's in the media gallery. Brew and cast is doing the recordings and they're automatically posted to the media gallery on Brew and Learn. I don't control when they get there. Yeah. Media Gallery under Brew and Learn has all the recordings. It takes a day or so. It's not instantaneous, it's not that quick. Now let's talk about Lab zero because I promised that we'd talk about what the function is you have to write for Lab zero during class. I wanted to talk about once again what negation is and how we actually do it. If I have a number X and I want to negate it to get the negation of X, I complement each of its bits and I add one. Here I did an example with just the number seven and seven is just one, one, one. Did I do that right? Yeah, I did that right. Four, two, and one. Then just to take the compliment, you'll notice that I flip the bits to one and I flip the bits to zero. When I add them, you'll notice that I get all ones. Negative one. You'll also notice that when I have taken the complement of X, the bitwise complement of X, and I add one, I will get negative seven. This is what we mean by this. We just take The complement and we add one and we get negative seven. You can see that when we add them together, we will just seven and negative seven and two's complement, we will get zero. What happened when I added them together that had to have happened when we just had this bit representation to get zero? Does anybody know the term that's something I discarded something? Does it help if I go through the adding it again? Are people comfortable with adding two bit numbers seven and negative seven? We're good. Not good? Show it. We're good. We're good. I just wanted to remind us of that. The takeaway is to get negative X, take the complement of X, that means bitwise complement and add one. That's it. Okay. Now, I also wanted to talk about shift operations because I know that there were some questions about shift operations and that slide that we had last time had a lot of information in one chart and didn't manage the cognitive load so well. Here, we're talking about left shift. I want to left shift X, Y positions. In this example, what we do in this specific example, our X is 01100010, and we want to left shift The bits. I want to show you can anybody tell me what is going to be removed when I do the left shift of the first one? What bits are going to be removed? Anyone know? You can see that the zero, one, one, one on the left are what's going to be removed and on the right, we're just adding zeros. It's the exact same thing for the next value, when we left shift, we take off the three left most bits and we add zeros to the right. We talked about this last time that this is the same as multiplying by. What is this the same as multiplying by? Powers of two by the number of bits that you're shifting. Right shift is a little bit more complicated because go ahead shift it This is a good question. Somebody is raising concerns that what happens if you have signed and you shift? The bit operation is going to be the same, but what's going to happen, for example, if the left sign bit becomes zero, what did we just experience? Overflow. You can get overflow. For right shifting, what's going to happen is now the lower order, the rightmost bits are going to fall off and the difference is whether it's a logical shift or an arithmetic shift. In a logical shift, what happens is the bits that we replace, the ones that fall off with are going to be zeros. Let's see what's falling off. In this example, for the shift, these bottom two bits are falling off and they're being replaced on the left with zeros. Sure. So we'll talk about that with instructions too. We'll talk about instructions. Okay. As I mentioned that when you're doing the shifting, that if the amount that you're shifting, it's undefined if it's less than zero or if it's greater than or equal to the word size. Now, this was the difference arithmetic shift, what we've replaced from the left is what changes. The bits that fall off on the right are exactly the same. In both cases, the same two bits are going to fall off the right. But here, you'll notice that there's a difference because the first one has a most significant bit of zero, and that means that The bits to the left will be replaced by zero. That's arithmetic shift. But when the most significant bit is a one, the bits to the left will be replaced by one. We'll talk a little bit more about why this is important, especially when we're dealing with signed versus unsigned ints. You'll notice that logical and arithmetic shift look the same most significant when it's positive or it's unsigned there. But when you have the sign bit set to one, it makes a difference that we'll talk about again now. Okay. We talked about multiplication last time, but I wanted to talk about division because this is really important for lab zero. When we are actually doing unsigned division and we're doing the right shift, we're taking U, which is our unsigned integer and we're right shifting it K, what we're actually getting is the floor of U divided by two with the K. The floor, who can help us just to refresh our memory? What is the floor? The floor function. The floor of 3.53. Questions about this are so far so good. We recall what the floor is. This is the the smallest integer less than or equal to greatest integer, less than equal to. I hope Int mess it up. When we do division, arithmetic shifts is okay. We talked about this last time for four. We write shift it one and we get two. But what goes wrong with negative four? When we just do logical shift, We actually get six. This is the idea of sine extension that we talked about last time. This is the sine extension. This is the arithmetic shift meaning that we make sure that we get rid of the bit to the right, but we replace it with the most significant bit, which is the sign bit. This was an example of when we're thinking about sine extension, we had talked about this last time, how when you want to extend the sign inch, you're going to not just copy over zeros, you want to make sure you're copying over the sign bit. Okay. We had another problem now and what is happening now is when we do this 45. You'll notice that we correctly do the arithmetic shifts one, but when we do that, we get negative three. That is the greatest integer smaller than less than or equal to. But is that what we want is the question? No. What we'd really want is negative two. This is where the idea of a bias comes in and the bias is if I'm going to shift a number K bits to the right, I'm going to add a bias before I do that, which is two to the K minus one. Why does it make sense to do that? Why don't I just add two to the K? Why is it two to the K minus one? Sure. You want to get negative two. What you wanted to do is you want to add it to the next number, but in the case there's an equality, you don't want to make it wrong is the case. If you added two to the K, it would actually be incorrect. You want to the bias is actually what you're adding to push the modular arithmetic up to the next integer. Okay. Now let's talk about what signed power of two divide shift looks like. Here we have X, and we want to write shift it K bits. It's going to be the floor of X divided by two to the K, and we're using arithmetic shift. That means we're copying over the sign bit. When we have a negative, we don't want the floor anymore. What we actually want is the ceiling. This is the ceiling function. The reason why we want the ceiling function is because we want it to round towards zero. For negative numbers, if we wanted to round towards zero, we need the ceiling. For positive, we want the floor. Otherwise, we're going away from zero to do that. In order to get the ceiling, what we have to do is we take X plus our bias, which is two to the K minus one and we divide by two to the K. Just in C, to do that, we do X plus we can left shift one bits, which is two to the K, and subtract one. The one left shift is the same as two to the K. Then we take that entire quantity and then right shift it. Questions about bias. I'll check the slider now. Let's see. Questions are so far so good. I don't see slider right now I'm sure. Go ahead. Yeah. No, you can. I'm going to show you in a second. Yeah. For lab zero. I'll show you how to do in a second. Sure. Go ahead. Okay. Let's look at the concrete example we had. I just want to come back to this concrete example. Somebody was skeptical about this one and I just want to talk about what is happening. Let's look at the concrete example. We're thinking about adding the bias and in this case, our K is equal to one. We're just going to have our bias equal to the one minus one. Here, what we're adding to negative five is just one. Then we're going to do the shift. Just double check. Okay. What happens when we do the shift? By the way, what is this value that I have now? One, one, zero, zero, negative. This is two to the three, two to the two to the one to the zero, but this is negative. It's negative four. This is going to be negative eight plus four, which is equal to negative four. We took negative five, we added one, we got negative four, and then when we shift it, we get minus eight plus four plus two, which is equal to negative two, which is what we want. Shifting up. Some of the intuition that's happening is, what if I think this would be a problem if I had negative four and I added two to the K to it. Let's look at negative four. And we're going to add one to it. That's give me negative three. What happens when I shift it? We're just going to shift it to the right. Who can tell me what we're going to get when we shift it? When I shift it to the right, what bits going to fall off? One, I'm going to end up, I'm going to shift it. We're okay. Now, the reason why I did this, I said, what if I added two to the K instead? Negative four and I am going to add two to the K to it, which is going to be two. What happens now? Now I'm going to add when I add two to it, I'm going to get What happens when I shift it now? But now when I shift it when I do the right shift, I'm going to get negative one. Two to the K minus one is the most that we can add without pushing an answer that's divisible by two to the K to the incorrect answer. That's why we add two to the K minus one because anything that's not divisible by it will get pushed to the next one without making the other ones incorrect. Yeah. Does that help with understanding bias? That's what's happening with that. Your turn. Show negative 4/2 using four bits. Yes. Somebody was just asking, add bias only for dividing negative? Yes. I just showed it quickly, but it's good to refresh. Okay. Are people ready? I quickly showed this, but I want to just let you see. I'm going to put negative four here and using four bits. What do I do next? I want to divide by two, what's my K? It's just one. My bias is going to be two to the one minus one, which equals one. That means that I'm going to add one to negative four to get negative three. And then I can actually do the shift. When I do the shifting, I get which we know as negative two. This is adding the bias, and this is right shift one bit. This was an arithmetic shift and you can tell that because I made sure that when I dropped off the right most one, I replaced it on the left with the sign bit of one. This is negative eight plus four plus two, which equals negative two. Questions so far. We're going to put this all together now for lab zero, but I just wanted to make sure we have all the pieces working together before we jump into talking about what's happening for lab zero. We talked about this last time. I'll summarize super quick. I think we talked about this time. Unsigned addition is mod two to the W, and we also have subtraction. It's for signed, it's modified. Arithmetic addition or subtraction mod two to the W. For multiplication, we do a normal multiplication, and then we just truncate. Everything is the same on the bit level. For unsigned multiplication is mod two to the W, and then for signed, it's modified multiplication two to the W. But on the bit level, they are the same, which is important to remember. Okay, I wanted to talk now about our lab zero problem. For lab zero, you're given the problem Easy three fours and the only argument that it takes is some integer and the only legal operations that you can use are logical naughts, bitwise complements. Bitwise and bitwise exclusive or, bitwise or, addition, left shift, and right shift. Those are the only operations and we give a rating for the difficulty and then the max number of operations that you can use. But before we jump into this, somebody was asking, how did I know right here that it's K? I knew this is K, this K is equal to one because it's equal to two. That's how I knew it was one because two is equal to two to the one. That's how you figure out what the K is when you're doing the shifting. Okay. Questions about the problem are so far so good. For this problem, we want to multiply by three fourths and round towards zero. That's why we spent some time talking about the care with rounding for negative numbers. For positive numbers, the floor works great for rounding towards zero, but for negative numbers, you actually need the ceiling. Given an integer, how do we multiply by three without being able to use the multiplication operator? Did anybody think about this yet? There's a few ways that we can actually do this. Did anybody think about this? Sure. You could just add the variable three times, so let X be an integer. What we have to do is our result will just be X plus X plus X. How do you do this with shifting? Alternative? What's an alternative with shifting? Sure. Go ahead. Go ahead, please. Excellent. The suggestion that was just made is that what we can do is we can write shift X one and then add X. Perfect. I'll put parentheses so we're clear. That left shift is multiplying by two and then you're just adding X again. That's how we could get three times X without using the multiplication operator. Questions about this so far so good. That's the first part of this. The next thing that we want to think about is, how do we actually divide by four? This is nice because we have a power of two I'm not sure I can come back to that. How do we divide by four without using the division operator? That was the next part and that's some of why we spent so much time talking about division today. The nice thing for us is that it is a power of two. A quick way is we can just take the results and we can just write shift it. This is dividing by two to the two. But the problem that we're having is that if it is signed and negative, we're not going to get the right results. We are dividing by four. But the problem is this does not round to 04 negative numbers. That's the problem. Sorry about that. What's my bias? Bas, is it three, is it two? What is the bias? It's two. Two to the two minus one. You're right. Sorry about that. Yeah. The bias is our K is equal to two. Our bias is equal to two to the two minus one, which is equal to three. How do you actually get this to work with the operations you're allowed to use? Sure. Okay. Wait. Go ahead. So you get your right there. Okay and then is negative, negative. Let me start breaking down what was just being told of us. Valid C, how can we do this? I want to talk about what was another way to do this. You cannot do this on assignment, but I will show you how to do this. This could be result. Plus one shifted to the left plus one minus one. Then we write shift it. This is valid C, but you'll notice that you cannot use this on the assignment. Why is that? What operation did I use that you cannot use in assignment lab zero or assignment one, Lab one? The minus. You cannot do this on that's invalid operation. How can we actually do this? What we can do is we can define our bias to be the result. We're going to write shift 31. What is this going to do? We're not quite done yet. Go ahead. So this is an important thing, a use of arithmetic shift. If it's negative, it's going to fill this up with all ones. If it's positive, it's going to fill this up with all zeros. This is how you can actually have some control flow because people were wondering, well, how can I tell if it's a positive or a negative number? This shifting is what's telling us whether it's positive or negative because you're basically isolating the sign bit, and then we can take the logical end of that with three. If the number is negative, the bias will be Three. If it's positive, the bias will be zero. The first is how we are basically checking. Do I have a negative or do I have a positive integer? The bitwise and with three is how we're actually getting the bias. But if you were to write this in terms of C code, it'd be like if negative bias equals three, else bias equals zero. This is what this one line is doing. So far so good. I'm actually going to show you the code now. Here's the whole solution, which is just what we talked about. It'll be on the annotated slides because I promised to give it to you, but I wanted us to derive it first. But there's a couple of things that I wanted to mention is that when you're working on lab zero and lab one, you'll notice that it's very careful that you have to declare your integers you all of them before you start the assignments. I just want to mention that which is why bias and results are declared before we start. You can do assignment with the declaration, but you can't, for example, declare another. What I'm saying is the rules are saying that you can't just do int X here, say in here doesn't want you doing that. Okay. And this is exactly what this is exactly what we had just discussed over the previous things, the limitation. Questions so far. Sure. Oh, sure. Let me just talk it through. Someone is asking me to just trace it through. The first thing we do is we have our bias in our results. The first line where we have the results, we left shift it one bit, which is the same as taking X and multiplying it by two. On the next line, we take results and we add X to it again. By the end of this one, so this is the same as I'll put a comment in here. This is the same as two X. At the end of this line, we have result equal three X because we just multiplied by two the line before and now we're calculating the bias, just to refresh our memory, the first clause is where we're getting the logic for whether it's positive or negative. What this is doing, it's doing an arithmetic shift. Let me do this. If result is less than zero, what we're going to get is all ones. Else, it will be all zeros. Basically, what this is doing, it's isolating the sign bit. You're going to have all ones or all zeros. Then when you do the bitwise and what's going to happen with three, you're going to get if it's all ones, bias will be three. If it's all zeros, when I do the bitwise and bias will be zero. Because of the arithmetic shift that I just highlighted. This is the purple part. Finally, in order to do the division by four, we take the results, we add the bias, which is correct, whether it's negative or positive, and then we do the right shift two, which divides by four, which is two to the two. When we do a right shift, we're dividing by two to the number of bits that we have there. Sorry about that. Let me just use another color. Any questions so far so good? That's how I know it's dividing by four because I take two to the number of bits that I'm shifting over. Then we return the results. Questions so far so good. So far so good. Let me take the slido. Oh. Oh, I can't get to the issue. Is there a fiscal policy? Hold on. I'm just taking this slidh if you want to put any questions or ask questions? Possibly. Someone's asking about overflow for the difficulty rating. I'm not sure I remember all the difficulty ratings. I think this is on one of the easier ones. I don't remember this. In order to submit this, somebody was asking how do you submit this? In order to submit lab zero, once you get this running, now your main responsibility for this week is getting your environment working for lab zero and then you upload bits dot C. Some of what you're checking when you're doing the upload is you're making sure you can compile and then run the checker to make sure that your code doesn't have any violation. If you just type in what we have, you should get that it works perfectly. Someone's asking how to submit that. You do need the bias. The reason why and just to reiterate, somebody's asking, why do we need the bias? The reason why you need the bias is because it's asking you to round towards zero. When you do shifting in order to divide for positive numbers, you get the floor, but the floor doesn't round towards zero for negative numbers. You want the ceiling for negative numbers, which is why you add on the non zero bias. That's why we need the bias. We actually round towards zero for negative numbers. Okay. Any more questions? I'm about to move back to integer puzzles. The first thing that I wanted to do is talk about a couple of big things. I just want to summarize very quickly what happens with integer. We have that flowchart and I want to give you the two key points of that flowchart. The first thing is, if I have a smaller size or the bigger size, which size wins from the flowchart. The larger. The larger size. If I have signed and unsigned that are the same size, which one wins? Unsigned. I just want to remember that. You've choose the larger size, if they're the same size, you pick the unsigned. What happens when we have overflow when adding two unsigned numbers? The result becomes zero, the result becomes negative, the result is U max too low, or the result is two to the W too low. What happens? When we have unsigned overflow, What happens? Result becomes zero, becomes negative, U max too low or two to the W too low. Let's look at a four bit example. What happens when we add 15 by 15 for four bits or let me pick another this one could be misleading. Let's say 13 and 154 bits. What happens? Sure. Pardon me. Pardon me? Unsigned. This is unsigned, yes. When I add two unsigned, these are two unsigned four bits and I'm giving this as an example for you to think it through. It's going to be too low by how much. We want this to be 28, but we know we can't represent this we can't represent this by four bits. What happens when we add this, we're going to have 13. The result is going to be zero, one, zero, one, I drop off. So, it should be one. I drop off the carry out bit. I get 12. That means I'm two to the four, which is two to the W off because we're doing arithmetic two to the W. Okay. Questions about this. It's just wrap around, but you only do this once for the number of bits. What happens when you overflow adding two sign numbers? Does anybody remember what happens for that? When you're adding two sign numbers, what happens? They change sign. If you have two negative numbers, when you add them, you'll get a positive result and vice versa. Two negative Positive, and then two positive will be negative. This is just showing that you're just going to have change of sign. You'll have a change of sign from the operands if they're both the same when you have overflow. Sure. Uh huh. Portion of the concrete example is here we did four bits. T to the W is two to the four, which is 16. Exactly. W is the number of bits. When we did this concrete example of 15 and 13, when we added, we had overflow. The result that we would have is just 12, but the answer should be 28. We're under by 16. That's what happened there. I'll just put that here. W is equal to four in this example, and we are two to the four equal to 16 too low. I'll highlight that for you too. This is the problem. Okay. Ready? I'm going to talk about the answers to last time C puzzles before we open up our own. But I wanted to give a little bit of a warning about using unsigned. What is wrong with both of these four loops? It has to do with something that happens with casting. Why will you be angry if you run this code? Probably hitting Control C at some point. Control C, Control D. Go ahead. The problem with both of these is that when you're using an unsigned int as the index for your for loop, it's always going to be greater than or equal to zero. This first for loop is going to loop forever, but what's a little subtle about the second one? We declare I as an int, but why are we getting the same problem? Pesky. Sure. Yes, the size of the delta is causing the problem because it's an unsigned. It's going to be an unsigned int, so we're going to be doing this comparison unsigned. In both cases, the warning that we should have is in both of these cases, you are going to be dealing with unsigned ints and these are going to loop forever. Before we get to the C puzzle, I want to give the answers for last time. I'll be going through these very quickly because we've already gone through them. The first one is actually false. Did anybody have a counterexample for why this first one was false? You can just let X be team in for this one. The second one is actually true and what we just talked about, let me number these. The second one is actually true and the warnings that I gave are dealing with that. Unsigned ints are always going to be greater than or equal to zero. Number three, this one is actually what were people thinking for this? This one is a little bit tricky because it's saying something about the last three bits. It's not saying that X is equal to seven. It's just saying that when you take the bitwise and all this is saying is the last three bits are going to be all ones. This one is actually going to be true. The reason for this is we know that the first part means last three bits are all ones. That's what this means. It doesn't mean that X is equal to seven. It just means the last three bits are all ones. Then when we shift them to the left, we're going to get a one in the most significant bit. The sign bit is going to be one. Which would be negative. What is happening with the fourth one? This was actually false. The reason why it's false is that when we do a comparison between unsigned and assigned, the negative one is going to become unsigned. Basically, it's going to become U max. That's the problem with that one. Because when you have unsigned and signed, it becomes interpreted as signed. For the fifth one, just very quickly, this one is going to be false. Can anybody give a counterexample of why this is false? What happens if Y is team in? This one is also false. Number six. Does anybody happen with six is going to be greater than or equal to zero? What's something that could happen with six? Why this one is? What did people have for six? Six. This one was false because of overflow. Seven. What about seven? Seven. This one's eight. Seven for this one? They're both positive, but yeah, the same. This one's false for the same reason for overflow. I'll fill in more specific. Thanks. What about eight? Is that true or false? What do people think for eight? This one's actually true. Why is that true? Because for signed in, if it's positive, it has a corresponding negative value. It has a corresponding negative value. This is actually true. I'll fill that in. Let's try the round two and then we'll take a break after round two. I'm going to get started now. These are a little bit harder, so I am going to give a little bit longer. I'll give you time to get on. Okay. You should be able to join now. And you don't have to use your name. Okay. We'll give it a few more minutes and then we'll take a break after this. Okay. Everybody ready? Who wants to play long? All right. I'm going to start the first question. You have a minute. So just for the sake of time, we should get started. I put the solutions up for the C puzzles up here and I'll put more detailed solutions for the other ones. But just for the sake of time, I need to start basic assembly today. The first thing I want to talk about is endness and data representation. One thing that we'll talk about a little bit more carefully when we get to processes that we take for granted is that every process that you're running thinks that it has this huge amount of memory, all the memory on your computer to itself. That illusion is provided by the operating system, and I It's not really worried what other processes are doing. The way that we envision it is we think the abstraction that we use for memory is that we think that we have this huge array of memory, just arbitrary large bounded by the address base. But it's really not like that at all. But in terms of how we think about addressing, that is how we think of it. We just think of the addresses by bytes, like the addresses that we use into an array. And so here, our address space is actually byte addressable. So when we're looking at addresses, we can actually get the address of each byte. And what we're doing is, every byte has its own address, and the size of the addresses is determined by the architecture. The reason why we use bytes is because it would be a lot to do it by bits. So by doing every eight bits, by doing the addressing by bytes, we can actually save some space because our addresses can be 32 or 64 bits. So in the case of X 86, we're actually dealing with eight byte addresses. And so our size of the address space is actually determined by the size of the addresses. So as I just mentioned, we're dealing with 64 bit word size, so we are dealing with two to the 64 addresses, which is enormous. And we also have this notion of word size, which we'll talk about also and that depends on the architecture. Okay, so this is why I was mentioning whether we have 32 bits or 64 bit words is because it determines the addressing. For example, when we can think of these addresses just going a and you can think of these all in heck, just going down zero, one through that. Each byte is numbered, but then we think of this based on the word size, whether we're thinking of the addresses in terms of four or four for 32 bits or 8464 bits. And here we can see that when we're thinking of the addressing, we just have either addressed for 048 12 or when we have 64 bit, we'll go 0-8. Okay. Important aside. One thing that's happening with X 86 that we have to worry about is Indianness. The notion of Indian it has to deal with how we actually interpret the ordering of the bytes. These are for multi byte data types, which is what I want to emphasize right there. When we read numerals, we actually think of them in terms of left tray. What I mean by that is when we're reading them, when we read and write, we're thinking in Big Indian, meaning that the most significant uh digit is to the left, then the next most significant, and then the least significant. But when we're talking about little Indian, it's actually reversed. What I mean by that is that the most significant is actually all the way to the right, the lower and then the next significant, and then it's actually reverse. The difference between big and little Indian is actually reversing where the most significant bits are. When we read, we usually think of this Let's see what this looks like. Suppose that we have this four byte value, how do I know it's a four byte value, by the way, in hex? How do I know that it's in hex? Just to review. Now we're going to be seeing variables X given in hex. The way that I know that it's actually four byte is I know it's in hex because I see the zero X, and then I can see the four bytes. I go, just take pairs. Each pair of hex digits is a byte. That's how I know I have a four byte variable X and the addresses are actually given above it. We have 1000 going to 1003. When we have this laid out in Big Indian, what we can see is that the lowest address has the most significant. But for Little Indian, it's actually reversed. I just wanted to point that out that for Indian is it only applies only applies to multi word. This is important because if you just have a char, that's just one byte, so you don't have to worry about Indianness or not. It's just how it's actually laid out. I'll give a concrete example of this. Another thing I want to mention is each pair Each pair of hex digits represents a byte. That we highlighted. But now we're talking about how it's laid out in memory. One thing I want to mention is you'll notice that the bytes are not reordered. The inside the bytes stay the same. Notice that the bytes. What I mean by this, you'll notice that 67 doesn't become 76. It stays the same. This is what I also meant when I talked about a char. A char would also look like two hex digits if it's encoded in hex and so that wouldn't change. Inside the byte doesn't change, but the endianness affects the ordering of the actual bytes. Here, with the ordering, with the endianness, we have the most significant byte at the lowest address and the least at the highest and for little Indianness, it's reverse in terms of the addresses. So that's the key thing. It's reversed of how we usually read things. The little Indiana has reversed it. B is how we're used to reading it, and then reverse is Little Indiana is reversing that. Let's see what this looks like for an integer. Spark is big, X 86 is little Indian. What is happening is that we have the same integer, but because it's multiple bytes, how it's laid out in memory is going to be different. I just want to mark out what the bytes are going to look like. Here we have four bytes. I know that it's a byte because two hex characters are eight bits. I have those four bytes. What's happening is how it's laid in memory is actually different. Spark X 86 is Little Indian, Spark is a Big Indian. You'll notice that in Big Indian, the way that we read, you'll notice that the most significant byte 00 is at the lower address and then we put them each down sequentially going to the least significant byte. In X 86, it's reverse. Spark is Big Indian and X 86 is Little Indian. Spark is how we usually think of when we're reading from left to right, most to least. X 86 Little Indian reverses that. In order to get the most significant, you go to the highest address, which is 103, and then you read it back from right to left, basically, when it's laid out horizontally. Questions about Indianness. You can just think of little Indianness as reversing how we think of reversing how we usually read from left to right. I'll look at Slider to see if there's questions. Exercise storage weight? By the way, there's a couple of questions. I actually put this on the slide, some of the problems that we had for the C puzzles, TI when you negate it is TI. The negation of TI is TI, which might be some of those issues. Indianness will be on the test, but also the reason why I'm talking about this too is we're not going to get too much in memory, but sometimes when you look at instructions, you actually have to know how it's being laid out in memory because otherwise you would read it in reverse. That's why we're reviewing this. People are asking why I'm reviewing this. That's why. For X 86, we have to be concerned with the orders because X 86 is a little Indianness. Okay. Let's look at a concrete example now from this code that we could run if we want to actually print out all of the bytes. Here we have an uns char, like an array of characters, and we have the length of that array, which is in length. What we're doing is we're actually What's important too, you'll notice that we fix that bug where we didn't subtract, making sure it's greater than equal to zero. We're incrementing and making sure that the index into this array of chars is less than the length. Okay, so all that we're doing here now is we're going through each character in this array of chars, and we're printing out the values. That's all we're doing now. For each char, we're we're just printing it out in hex. So the P actually prints out the address, and then the X value, the X prints it out the actual value in the chart in hex. If we were to give the integer that we were just looking at in terms of the addresses, this is on an X 86 and some of the reason why I know this is X 86 is because this is in Little Indian the way it's the first address is the least significant byte, and then it prints out the next byte up to the most significant byte. So this isn't Little Indian. What this would look like in hex is that's what the integer A looks like. When we're printing it out, the Okay. Now, this is what I meant with that only pertains to multi byte types because when you just have a char array, nothing gets reordered because each char is just one byte and you would just keep it in the order in which you had it ordered. In this specific example, we have an array of chars 18213, and you'll notice that they have the same order on little Indian or big Indian because the char is just one byte. Indy this only affects multi byte data types. It does not affect just s, single bytes, so it stays exactly the same. Questions about this. I'm also checking the slido. Okay. Now we're going to start jumping into what we wanted to talk about in terms of assembly. The point of the instruction set architecture, we talked about this on the first lecture. You can think of this as an interface between the software and the actual hardware and because of the instruction set architecture, we can use the same ISA on many different types of hardware as long as they work with the same instruction set architecture. So the architecture actually specifies how the software interacts with the hardware. It's a specific language understood by the hardware, so long as the hardware can speak X 86, you can run the code on it. The micro architecture is actually the implementation in hardware, so that's the processing unit, the cases and the register file. And so when we have a compiled program in an ISA, we have two forms that we're going to be looking at. We have machine code, and we also have the assembly code, which is the text representation, which you'll be able to read and write. So we talked about this last time that when we actually have the model of execution that we're using, that we actually have data in memory and we also have our instructions in memory, and we actually go from one instruction to the next. But I wanted to talk about what's in the micro architecture because we haven't talked about that yet and we have to talk about it a bit in order to think about what is happening with assembly code. We'll talk about the cache a little bit later and how you can write code to exploit the cache. But what's going to be most important for today is going to be the register file. We had not introduced the register file yet and the registers are right on special fast memory that is right on the CPU. That is what we're going to be introducing. The registers are special Fast memory on the CPU. And we do not have to worry about Nines for them. This, by the way, is an abstraction. These arrows are abstraction for the hardware because there's actually buses. The buses that will actually take addresses from the CPU to memory, take data back and forth and will also take addresses back from memory. This is an abstraction for the buses. Then we also have main memory and the DRAM. In main memory, we can have code, we can have data, and we can actually have our stack. The nice thing with X 86 is that we can actually have instructions that can write directly from memory or can read directly from memory. We'll talk about the addressing mode for that. Why are we bothering with X 86? Is that there are many different computers that use X 86. The problem is that it's a hodgepodge and backward compatible instructions, so it's a complex instruction set. What we're going to do is we're going to focus on those instructions that are most commonly used by compilers. Sometimes there will be instructions that we will not get to and that's fine, but you'll understand actually how to look them up and read them. So let's talk very quickly about the process that you go from C into an object code. Suppose you have two C files, P one, P two, and we can use Gcc on them. We do Gcc OG is just for the optimization, and then we specify the two files we want to compile and we do O to P means we're saying that we want our executable our binary executable file to be named P. And so when we actually use the compiler GCC on our files, P one and P two, we first generate text file, which is by the assembler, so we'll have an assembly file, then we'll generate binary file, and then the linker will link the output for P one and P two with any static libraries or possibly dynamic libraries and link them to create our executable program. And we'll get more into this specifically a little bit later in the class. Here we have a function in C that calls a function plus, but it also just some store where it just takes too long and puts the result of adding them together in a destination that we have that we're passing in as a pointer. And so here we can actually get the assembly code by using GCC OG optimization and the S. So the S will actually give us the X 86 assembly. So if you want to get from C to X 86 assembly, you can use the plaque, and the OG is just for the optimization. And so this is an example of some of the assembly that we're going to be looking at. Okay. Object code, it's not meant for humans. We'll read a little bit of in the attack lab, but you can see that's why we work with assemblies because this doesn't necessarily make such great sense for humans. But anyway, another way to disassemble code is to use object dump. You can use object Dump minus D and the binary file, and this will actually give you the disassemble code. Now what's good about this is it gives you the human readable X 86 to the right, the assembly, and it also gives the machine code to the left. On test, we'll actually give this. And for Boblab you'll get this, this inverse, object done minus D and then the binary file. That's what you'll actually get. Now we're going to jump into what is actually happening with this code and we're going to be translating from the C to the assembly and also the machine code. The first thing what we have is we declare a pointer to a long, which is desk, and then we actually save the value T in the location that's pointed to by desk. You'll notice that the The star desk is de referencing and it's just saving into that. In assembly, this can be done with our instruction called move. Move Q and the Q stands for quad word. You'll notice that there's many different variations on move that we'll be talking about. But move Q is just for a quad word, which is an eight byte value. So a couple of things when we look at this instruction, RT is in register Rx, you'll notice we're moving the value Rx and our destination is RBX. You'll notice that the parentheses around Rbx is saying Rbx is a pointer to an address. I want you to go to that address and copy what's Rx into that address. So the parentheses is is telling the hardware, go to this address that's stored in this register RBX and copy what's in RX into that address. The parentheses are actually dereferencing a pointer. That the register RBX contains an address. And that parentheses around RBX is what's telling that we're de referencing that address for MV cue. Here we get a three byte instruction that you'll see a lot more of these on the byte lab, the machine code, which it actually gets. This instruction 488903 is basically the same as that MV cue instruction and on the attack lab, you'll spend some time actually dealing carefully with the machine codes, but for right now, you don't need to worry about the machine codes. We're just going to worry about the assembly for now. Questions so far, so far so good. Instructions that we'll get to next time and over the course of the quarter is we might want to add the values in registers. We might want to push register onto the stack and the stack is in memory. We're also going to talk about how we can do some control flow starting next week in terms of once we make a procedural call as we can in assembly, we're going to want to return from those procedure calls and we'll talk about that next week. Okay. The basic types that we're dealing with are integers of one, two, four, eight bytes, floating points of four and eight. By default in our registers, we do not have any aggregate data types such as array or structures. But what we do for this is we put our arrays or structures in memory, in main memory, contiguous blocks of main memory. We don't put them in the registers, we put them in main memory, and we'll see some concrete examples of that. Okay. This is another way that you can actually in GDB, if you're still comfortable with GDB, you can also disassemble in GDB by doing GDB args in the name of the function you want to disassemble and disassemble some store or you can actually go to the memory where some store is and you can see this assembly. We'll talk a little bit more about that, but I just want to say if you're looking at code, you could do that also. Oh, this is where the Indianness comes up. This is where the Indianness comes up. Here the instruction is and we haven't talked about this yet, but sometimes you don't want to add two registers. You want to add a constant value, an immediate value to a register. When you see $1 sign and a number in hex, it's saying, I want to add this value in hex one, two, AB to whatever is in this register EBX. But what could get confusing if you don't remember that X 86 is in Little Indian is you'll notice that in the instruction, This is actually written in Little Indian, meaning that you actually read it from right to left. You'd have AB one, two, zero, zero, but it's actually written in Little Indian. That's the difference that I want to mention. Any constants that you have constants for intermediate values are going to be written in Little Indian and that's what's going to affect how you actually read the code. That's where the Little Indianness comes up. Okay. Questions about this so far so good. But that's why we were talking about the Indianness is because if you actually have any values like immediate values you need to read to you don't read them from left to right, you read them the other way because of the Indian. Sure, go ahead, by the way, the question that was asked, does it only affect the instructions? No, it doesn't. It also affects in memory. If, for example, you took a value and you wrote it into memory, if it's an integer, so four bytes, it's going to be written in little Indian. If you start looking at GDB at memory, it's going to be affect that also. Assembly. Oh, you can write it assembly the way that we read it. You can write it the way that you think about it like humans reading it left to right, but in memory, it's going to be laid in Little Indian format. Yeah. You write the assembly the way that we usually think from left to right, this is what we mean in hex, but just know that it's going to be stored in memory in little Indian format. We'll give more examples of that, but I just wanted to warn you if you're looking at code, that's what's happening. Now let's talk about the register file. It's a lot to actually unpack. On the CPU, we have register files and I'll talk about what these registers are in just a minute. We have a program counter which actually helps us keep track of what instruction that we're at. We'll talk a little bit more about that next week when we get into control flow. But the register file, you can think of as what you want to use for your temporary data, and this is maximizing use of registers is what can make your code very efficient. And then across the buses, we have main memory, say DRAM. We're not going to talk about the cache, and we'll talk about condition codes, our special subset of registers that we'll talk about next time, how they're used for control flow. In any event, we also have these buses which communicate the addresses and the data between, main memory, and the CPU. Today we're going to focus mainly on the register file and a little bit about how we can actually go between the CPU and memory using instructions. Questions about the register file so far. Just so you can think of this as small little bits of memory that are extremely efficient that the CPU can use very efficiently. It can actually tell us how to get to main memory too. Here are the registers, the integer registers for X 86. You'll notice that one thing that's very confusing is that these very same places in memory are actually called different things sometimes. The reason for that is backward compatibility. For example, when we have these registers, there are four bytes. But for backward compatibility, the registers also have a name that are four bytes. They are eight bytes, for example, we have the register rex. But if you only want the lower order four bytes, you can refer to that as ex. We have the register RBX and the lower order four bytes, you could refer to that as EBX. It's the exact same register. It's whether you're writing all eight bytes of it or whether you're just writing the lower order four bytes. That's the only difference between Rx and Ex or Rbx and EBX and so forth. We have these eight byte registers and We're going to talk about how we use them. Some of them are used for a specific purpose, and we'll talk about that a little bit more over the next week or so. Eight byte registers when the name starting with R. If it starts with an E, we're talking about the same register, but the lower. It gets more complicated still. Because if you wanted to, you have 16 bit virtual registers also. If you wanted to just talk about the lower order two bytes, you can just call it ax or cx. Or if you just wanted the lower byte, you could call it AL or AH for the second, the higher of those two. They are physically the same register. It's whether you want to talk about which byte you want to actually be writing. Let's talk about moving data. We actually saw an example when we were talking about copying T into star desk of move, but now let's break down the move instruction. Move Q, which means move cod word, which is going to move from a source, which is the left operand into the destination, which is the right operand. You can have Immediate value, which is just a constant value as the source. You can have 400 and hex 400 and hex, or you can have negative 533 in decimal. You can tell that it's immediate value because the immediate value is going to have this dollar sign before it. That's the clue that you have an immediate value. It's a value with the dollar sign before. It's usually written in hex, if it's not in hex, then you can interpret it as decimal. Okay. We can also have the registers be either the source or the destination or both. For example, we can have the register RX or R 13. And the other type of argument that we can have is memory. And we can tell if we're actually accessing memory because around the register names, we're going to have parentheses. This is the indication that we're actually accessing memory is if you see parentheses, It's telling us that we are going to interpret whatever value is in the register as a pointer and we are going to access main memory at the address pointed to by that register. Questions so far so good. Sure. Pardon me. EB, sure thing. Immediate is just another thing for a constant, just a constant. If we want to move, say a constant value into a register. I'll put a concrete example. Say I want to put the value 400 in hex into Rx. When you see $1 sign before the value, that means I interpret this as a constant value integer value. Otherwise, you might do something like, and I can put this here, we can do say move Q whatever value is in Rx to rbx or the third case that I'm talking about is we can move whatever is in Rbx to the memory pointed at by Rx. What's really important is that when we have move instructions, only one of the operands can access memory. We can't go from memory to memory. We have to go from memory to register and then register to memory. You can't do both at one instruction. Let's look at some more concrete examples, but I just wanted to summarize what the differences were right there. First set of examples is immediate. Here these actually are doing two different things. The first instruction is saying move the constant four into the Rx register. The second instruction is using an immediate value, but rather than going to register, it's going to memory. This is saying move the constant negative 147 into the address stored in register Rx. Okay. So these are both examples of using immediate values. One is copying the immediate value into a register. The second is copying the immediate value into the memory at the address stored in the register. That's the difference. I knew this because of the parentheses. That is what is reminding me that this is going to access memory. You can think of this as when you see the parentheses, you're dereferencing a pointer. The pointer is the value stored in the register. Now, these are examples of instructions between registers. The first instruction is saying move the value in Rx to register rdx. That's register to register all in the CPU. This next instruction is between registers, but it's going between registers and memory. It's saying move the value in Rx to the address stored In RDX. Once again, I know that we're accessing main memory because I see those parentheses. Even though the operands are registers, I know when I see the parentheses around the registers, I think of the value in the register as a pointer that I'm de referencing. I'm copying the value in the register Rx into the address pointed to by Rx. This is similar, but here we're taking something from memory and we're storing it in a register. Here we're saying move the memory stored at the address in Rx into register rdx. The eight bytes of memory. Okay. Once again, I know this because of the parentheses around the register. Tell me I'm thinking of the value inside that register as a pointer. I'm dereferencing it, meaning I'm getting that memory from main memory and I'm copying it into the register. I want to put in red what you cannot do. What you cannot do is this is not permitted. I cannot do something like this. This is an attempt of going from memory to memory and you can't do that. So this is not permitted. Sure. Just the instruction sets so it doesn't permit it, great question. The question that was just asked, what if I want this effect? You have to have two instructions. Let's show how we can do this. What we can do is that you can do something like this where you can take whatever value is at RX, put it in another register like RBX, and then you can move whatever is in RBX and you put it in that address. Yeah. That's what you can do. You have to do two instructions. You can't just do this in one. You have to go from memory to register and then to register the memory, you can't go between the two. Other questions. I think we're almost at a good stopping point. But let me just summarize. Let me see if there's questions on Slido. Let me check. By the way, somebody did ask me discussion. Just to reiterate, del your pot is in your discussion in which you're enrolled. That's not happening. I get it. What you can actually do is make sure whoever's doing your check in has to go together to the same discussion. It does not have to be the discussion to which you're enrolled. They just both have to be at 10:00 or noon or 2:00. They just both have to go to the same discussion and it's fine. You don't have to intend the discussion in which you're enrolled. I apologize. Someone might be asking me to go slower, but, somebody asked me about this. Somebody just asked me about what if we wanted to do this? What we just talked about was the equivalent of doing P one equal P two. Why we needed the two instructions. We can't do register to register. I think we're good. I just want to summarize what we did in terms of addressing and then I think we should call it a call it a day. What we just saw is the simple addressing mode. The simple addressing mode is where you have the parentheses around the register and you're using that as a pointer and you're moving from that address to a register. That's what the parentheses mean. We'll talk about displacement next time. We'll talk about this more detail next time because we didn't give many examples, so this is good. Awesome. Thanks everybody. I can answer some questions.