First, I want to talk about what buffer flow overflow attacks are. Take a moment to look at this code. We have a struct that contains an array of integers and a double, and then we have this function that is going to create an instance of the struct, set the double equal to Pi, and then set the integer at index I where I is the argument to the function equal to a very large integer and that line is bad. Can anybody describe why that line in this function is bad? Setting the h integer, yes. It is possible because it's not checking that the index given is at most one, so it has to be less than two, so that's why we could actually have an overflow here. Here, when the function is called, we have the return address and you'll notice in gray that we have the stack frame for this function. At the beginning of the stack frame, you can see that we have the integer array because we just allocated a struct. We have the integer array, so the integer zero, and index zero, and index one, and then we have the double D, which is allocated for the struct. Then as you notice sometimes with stack frames, the stack frame is actually gives some empty space aside from what's allocated, so that's what we can see there. Okay, now we're going to trace through what's happening, and you'll see that when we've summarized it here, everything's looking good when we're using a valid index for the integer. When I is zero, it's fine, I is one is fine. When I is two and three, we're getting some weird errors with the double, and when it's four, it's good again. And then when we pass in six, we're getting an error. Does anybody have ideas what could be going wrong? The first two is valid indices fine, but then you'll notice that we're getting some erratic behavior when the index is incorrect. Even correct answers returned when we have something such as the index is four, trying to access the fifth integer in this array. What could possibly be going wrong? Any ideas? Sure. Right. Some of the mistakes we're going to see is what's happening when we're trying to actually write over something that's not part of the array and if it doesn't overlap with the float or not. That's what we're actually going to see. Okay. We're also going to review a little bit about what is happening with how the double is stored. Here we can see that the double is actually going to be stored. Here we actually have four bytes. In this diagram of the stack frame, there's four bytes. First we're going to have four bytes. So then we have the A zero, the first int, then a one, the second int, and then we have the bytes of the double on the next eight bytes. I wanted to review floating point representation very quickly because this will help us with this problem. Here, When we have a double, we have 52 bits of the fraction, 11 bits of the exponent, and then the sign bit is the same. With the single precision, we just have the 23 bits of the fraction and eight bits of the exponent and we still have the sign bit. I had a question about the midterm question. Why was that midterm floating point question didn't actually require any multiplication? Because we're saying we gave you a floating point number and then you're going to multiply it by four. Why did it require any multiplication? Go ahead. That's right. When you're multiplying by a power of two, all you're really changing is the exponent E. You only had to add two to the Exp field in order to actually figure out what the representation would have been if you multiplied by two to the four. You could possibly get overflow to positive infinity for that problem or negative infinity if it's a negative number. But when you're multiplying by powers of two, you really only have to change the exponent, the Exp field, add to it. Other questions right now so far so good. Okay. So what I did beforehand is I took the number 3.14 and I have the binary representation of that number, what would actually be in the floating point, and then I have it in hex. The reason why I do this is we're going to be seeing what happens when this is placed in the struct and how it's going to be changing as we overwrite different indices of the survey. This is the representation of this as a double. Those are the eight bytes for questions about this, so far so good. You don't have to worry too much. The main important thing is to know that we're going to be overwriting that. Inside this function now, you'll notice that the first thing that we do is when we get to the line D is equal to 3.14, we put it into the struct. We just write the floating point representation of 3.14 in those bytes in the struct. That's the first thing to note. Now we're going to see what starts to happen when we try to access parts of this struct using indexing relative to the start of the array, integer array now. Let me go back one. You'll notice that for this problem, it's good. We don't have any problem going on. Where is the value going to be written when we're passing an I equals zero. People knows for Is equals zero, where are we going to be writing this value? We're going to be writing it right here. Here, when I is equal to zero, we're going to be writing the value right there. I'll talk about what that is in the hex in a second, so there's no problem when we return because we actually wrote it in a valid place. Okay. And here I actually introduce what the integer is in hex so that we can see what we're going to be overwriting in a second. When I is equal to one, you'll notice that we write the integer value where a one is right here, and we have no problem with the floating point number at all because we haven't overwritten it yet. What's going to happen when we set I equal to two? This is the first opportunity we might have for some overflow. What's going to happen when I is equal to two now? Sure. Yes, it's going to overwrite the lower bytes of the floating point. Here you'll notice that here, it's not doing any checking, so it thinks that this right here is the array at index two. But you'll notice that at that point, there's no memory in the struct for integer at index two, that would be a third integer. What it's doing, it's overwriting the lower order byte of the floating point. As you can see, what part of the floating point is that going to change? No. The mantissa part. It's overriding part of the mantissa, which is why we're getting a number a little bit less than 3.14 is what's happening. It's actually just overriding parts of the mantissa is what it's actually doing. When A is equal to two. Are there questions about this? So far so good. Then when we get to index three, you'll notice that Here, we're getting the value two in very small decimal because what we've actually done is we've overwritten the fields that contain the exponent now is what we've done. Questions about this. Here we're actually changing the number, but you'll notice that we're getting the wrong result, we're overwriting the double, but we haven't gotten into any problems yet. What's going to happen when index is four? Where are we going to write this integer now? Sure. Right above it, and this is where We actually didn't write that value in any of the integer fields of the struct. We had the index being four, we went over the memory that's allocated in the struct for the double and now we're just writing in some empty buffer space that happens to be in the stack. It looks like everything is fine. The value that we get returned is 3.14, the value that was actually written to the double because we wrote beyond it. Right now, we're overflowing the memory for the struct. This is the first example of where we're actually overflowing the struct. But so far it's not causing any problems because there wasn't anything there on the stack, so it looks fine. As far as our programs are concerned, it's looking completely fine. But now we get a segmentation false. The reason for this is that we've actually overwritten the struct memory so much that we've overwritten the return address. That's the issue that happens now. A without checking what the index is, you'll notice now we're trying to access the integer at index six. There's no such integer, but we've overflowed the stack so much that we're actually wrote over the return, the valid return address. That's what we just did there. Here, this is a problem because we've actually overwritten The return address. This is a concrete example of what we're going to be potentially doing on the attack lab, actually overwriting parts of the stack in order to take control of what the operation is going to be, not the intended operation of the code. Okay. So as you can see, this is a really big problem, and this is what we mean by buffer overflow, which is basically we're exceeding the memory that is allocated for an array or in this case for a struct. In that specific example, we not only overflow the memory for the integer array itself, we actually overflowed the memory that was allocated for the struct itself. Okay. This is a huge security vulnerability. Some of the simplest forms of this is you might allow people to input strings and you don't check the bounds on the input strings that you allocate a string of a certain number of bytes and you don't actually check that limit. This is a way that you can actually overwrite the stack and we're going to talk about some of the ways that we can actually protect against this now. This is some of what we're going to be looking at. But before we get into it, are there questions about what it is that we just saw and what we'll be doing on the attack lab? So far so good. Okay. Let's look at some code that lets us do this. Here, when we are looking at this function gets, you'll notice that gets is just taking a character, it's taking the pointer and it's just keeps on writing it and incrementing the pointer. Then it puts in a null string and just returns the destination. All it does is it just keeps on reading and reading and reading. You can see why is this a vulnerability. Can anybody see why Right. If you're looking at this, you'll notice that it's just taking the pointer to whatever the buffer is and nowhere is it checking the length of the buffer. It's just saying, okay, I'm reading a character, I'm going to keep on reading the character and just saving it at the next chart, the next byte in this array. That's all it's doing. It's not doing any checking to make sure that the array is big enough or not. This was some of the problem that we saw in the struct array. We only had two integers in the struct and we just kept on overwriting it. Here is an even more insidious problem because we're just giving it a pointer to a char and we just keep on as long as the user keeps on entering characters, we just keep on overwriting the memory. And this is a problem also with scanF. I think you may have seen this on the Bob lab. You might have seen scanF when you were reading in the input from the users for a different function. Let's take a look at what this code is looking like now. Here we allocate a buffer of just four characters and we call gets, and then we also call puts. Here, the call echo function is just going to call this echo function. First time we enter all of the digits. No problem. The next time we get a segfaults, Why could that be the case? We only allocated a buffer of four characters. What could possibilly be happening for this? Sure. It definitely went over, but why is one of them segfaulting and the other not segfaulting? Is the question. Sure. Pardon me, I didn't hear. Yeah. So that's what's happening. Sometimes you'll notice that when in the bomb lab you might have had the stack was greater than whatever you were going to write on it. You can keep on overflowing past that point, but at some point you might actually start overwriting return addresses or other things you need. That's what's happening. It doesn't always happen immediately. Let's take a look at what's happening with the code now in assembly. I'll give you a moment to look at that. I'm going to give another minute or so just to look at the code before I start talking about it, and then we're going to start tracing what's happening on the stack. Who can help us with the first two lines? You may have seen this from the bomb lab, the first two lines in red, what's happening in the code for echo before we start tracing it? Sure. Let's describe what's happening. The first thing that we do is this first line is allocating 24 bytes on the stack. That's what this line is doing. The next thing that's happening is we're moving the stack pointer to RDI, which means we're setting that to be the pointer to the buffer that is going to be filled by gets. We're passing The stack pointer as the argument to get when we put it in RDI. That's what's happening. We allocate more space on the stack and then we put past that as the pointer to where it gets it's going to start filling up the buffer. We'll get to this a second and then you'll notice that call echo is just calling echo. But when we make the call, what's important about the instruction after the call? Call echo is going to make sure what's happening with the instruction after the echo. Go ahead. Go ahead. Yes. The address that we have in red, that's the return address. When call echo makes the call to the echo function, it is going to make sure that it writes the address of the instruction right after the echo call as the return address before it starts the stack frame for getting into call Echo. Those are the two main things I want to talk about and now we're going to start tracing this stack, but I just want to see if anybody had any questions about the code or what we're going to be doing. You'll notice that because we're passing the stack pointer for Echo, that's where we're going to start overwriting. It's going to begin. Okay. This is what we were just summarizing. The call echo function is going to be put the return address right after the call echo onto its stack frame. Then it allocates the 24 bytes that are in purple. That's creating the stack frame for inside echo note, the stack frame for echo function. You'll notice that the buffer is starting right at the top of the stack. It allocates the four byte buffer at the top of the stack, and then it calls get, and that's where it's going to start writing exactly where the buffer is pointing at the top of the stack. Okay. As we had mentioned, you'll notice that we have updated the return address from call echo to be the instruction right after the echo call, which is just 40 06f6. We put that at the bottom of the stack frame for call echo and now we're going to go inside the echo call now. Let's look at what's happening now. We have that string that we wrote and maybe now it's making more sense why one of the series of characters we entered overflowed and the other one didn't. Here, you'll notice that and I just want to mention something here that zero in ASC is 30 and all the other digits are relative to that. One in ASCI is 31. I just want to remind you this, what's happening now? Someone just typed in this string of characters. Why are we not having an issue yet? Sure. Exactly. This is the buffer, and I just want to point out right here, the buffer is only right here. These four bytes. That's all that the buffer is. You can notice that once we start writing right here, we've actually overflowed the buffer. We are overflowing the buffer. But we don't have an issue yet in terms of the segmentation fault because we all the stack frame had actually allocated the 24 bytes and we haven't actually used, all of the allocated stack frame. So we allocated extra memory in addition to the buffer, and we filled this up all the way to, and this is the last character. This is right here is two. So we're okay. And this is the last one. You'll notice that we didn't actually start overwriting the return address yet. That's what's happening. We overwrote the buffer, but we haven't actually overwritten the return address. This is similar to where we wrote the floating point right after the integer array in the struct. We overflowed the integer array, but we hadn't actually overwritten the return address yet. That's what just happened there. But now let's see what happens. When we enter the additional two numbers three and four is where we have the problem. What I mean by that is when we entered it is three, we're overwriting this right here, this is three. Then you'll notice that when we write the four and the null character to end that string, that we've actually changed the return address because we've overwritten the return address. This is where we've actually overwritten The return address. That's what we mean with buffer overflow. We've not only overflowed the buffer that was allocated by the function call echo, we've allocated all of the extra memory that was allocated for the stack pointer when we put 24 bytes when we subtracted 24 from the stack pointer and we've overwritten the return address for the next instruction in call echo after the echo call. Here's a problem because we've actually corrupted the return address. That is the issue that we have. Some of what we're going to be looking at attack lab if you've looked at is knowing that you can do this, what does this enable you to do if you can overwrite the return address? If people have looked at the attack lab, what does this let you do? Have you thought about this? Go ahead. You can return to your own code. You own code that you've either put or other code that's actually available within the memory of the program. That is that's what the attack lab is actually looking at. You're overwriting the return address and in this specific case, we would get a segfault. But here, say we stopped at 33 at the last three. You'll notice that here's the last number that we wrote and here's the null, the last three that I just underlined. Here we overflow the buffer, and we overwrite the return address. But why isn't this a problem? Why might the program still work? Go ahead. It might turn out that this address that you overwrote could actually be a function for code that you can actually run. The program will still run. Here it's not what you intended. It's another program. When you overwrite the return address, when you when Echo returns, it's going to take whatever address is written there and it's just going to start running that code there. This could be bad if somebody else is doing it, but on the attack lab, you're intentionally trying to take control over what's going to be happening by overwriting those return addresses to be where you want the code to be executing from. We'll talk about different ways that you can do that in a second, but this is the main point of what's happening in a buffer overflow attack. Eventually, you'll get back to the main execution, but possibly not depending on how skillful the person is in taking over the execution through the return values. Okay. I just want to pause a moment to say, are people clear with what we mean by a buffer overflow attack? What's happening with a buffer overflow attack? We're good. Cool. What's something interesting that you can do? Now you know you have the power. If I start overwriting the return addresses, using buffer overflow, I can start executing code that I want. In this specific case, we went to another function that maybe you know about, maybe you don't. But what's something else you could possibly do that's very powerful. Say if you know where the start of the buffer is and you know where the return address is? What's something powerful that you can do? Go ahead. Yes. That's exactly what we're going to look at now. The main idea is you can take the return address and make sure you have it pointing to address of code that you have written. This is called a code injection attack. Okay. We know we have this buffer, we know we have some extra stack space, we know how much it is and we know what the return address is. Here, we know that the buffer B, we know the start of that, say that's the top of the stack. What we can do is we're going to overwrite the return address to be the start of the buffer. But the other thing that we're going to do that's very powerful, we fill the buffer up with code that we want. That is what's called a code injection attack and we're going to do a concrete example of this a little later, but I just want to say that this is what we're actually doing. What happens is that When Q gets executed, it's actually going to return, take whatever return address you overwrote there, go to the start of the buffer, if that's where you pointed to, and run your code. That's what's actually going to happen. Okay. This is how we can actually use buffer flow. What happens is once that gets called in queue, you take the buffer, start the buffer, you start filling it up with any exploit code that you want to run, and the way that you make sure that your code gets run is that as part of your attack, you overwrite the return address that's going to be called to the start of the buffer so that it starts running your exploit code. There's two things happening here. One thing I want to mention is the first thing is one, overwrite the buffer Starting at address B with the exploit code. The second thing you need to do is make sure that the return address is overwritten to the address of the code. Okay. Sometimes in order to do this, you wouldn't necessarily just jump like, I'm going to write my exploit code at the start of the buffer and then overwrite the address. You'll just put in some filler, which we call padding in order to get to the right memory address to overwrite the return address. That's what the other thing you'll have to do. You'll just put some padding and we'll look at examples of padding. For the attack lab, the padding could just be all zeros. You write the code that you want, some amount of all zeros to you get to the return address and then overwrite the return address to be where your buffer is where you wrote the exploit code. That's all you need to do for that. Okay. So these buffer overflow bugs are Actually, there was a real one. It allows remote machines to actually take over and execute code on their victims machines, if you can overwrite the buffers. That's some of why it's common, but we'll talk about how to protect against this in a second. If you make the mistake like calling gets and not checking the buffer length, this can actually happen in your own code. The Internet worm that took down the Internet in 1988 actually did this, propagated very quickly. But in the attack lab, a couple of things you'll learn. You'll learn how to do it, but you'll also learn how to write code to prevent somebody from doing it to code you wrote. So that's what we'll be doing on the attack lab. I want to check for questions and see if there's any questions. You can ask questions. If people have questions right now. I'm checking the Slido. 24 at the beginning. So, I just noticed a few questions that I want to answer from the slido now. Empty memory of the stack below the returner just always eight or it could be, so it does depend. Sometimes the area, so I want to go back to this. Sometimes the amount of padding between what's allocated the return address and where you might think the top of the stack is different. It's not always just eight bytes, it could be different amounts. That's one question. What happens with F seven? That could be a site fault also because someone was asking with the function seven because then you're writing into another function stack frame. The difference between the memory allocated by the buffer and other memory in the stack, why don't we allocate a buffer to 24 at the beginning. Oh, I see the question. I see. Someone was asking, why don't we just allocate a buffer of 24? I mean, it's possible that you could allocate a buffer of 24, but then the compiler will put in more space, the stack frame between the buffer that you allocate and the return address. You may have noticed that on the bomb lab where there was always extra space between whatever you were working with and the return address, that's the additional space that will be there. Okay. Yes, there will be extra future lectures, we'll have extra credit opportunities. The main reason why today we're going to be working on some attack lab exercises to help you get started, but to also help you for tomorrow. Tomorrow's discussion is going to be a little bit more brief, especially if you want to talk about midterm solutions. I'm trying to make sure you're at a point where you can start working on the attack lab tomorrow basically today and tomorrow. That's why we're rushing today a little bit. Okay. Other questions? Yeah. You could override it even further still, you could. What's happening too is that, and we'll get to this a little later. Right now we're just talking the case where I'm just going to put one return address. You can put a series of return addresses to string together code that you want to run. We'll do that. We'll look at that also. Let's talk about what can we do to fix buffer overflow attacks? Okay. There's a few different ways that we can actually address them in our code. The one thing that we can do is we can be careful in our programming. The second we'll talk about is system level protections and then some things that the compiler does, and these are stacked canaries. Okay. One simple thing you can do in your code that is super important to make sure is don't use gets. Do not use gets, use something like F gets where you actually have to put in it the length of the buffer. This is why this is so important, is that something like F gets actually requires you to put in the length of the buffer, unlike gets. This is why if you need to be reading from a buffer, you have to specify the buffer size. This is something that you can do as a programmer to prevent overflow of tax because once that limit is passed, it's not going to keep on reading. That's one example. Using F gets instead of gets is one thing that you can do. Similar thing with scanF. I don't know. Are you familiar with scanF, by the way? SanF scanF it's when you're reading the input in, but you can actually make sure that you put a limit NS to tell how many characters that you're going to read. The first thing is don't use the versions of these functions that don't give limits to the buffer size. Okay. The other thing that you can do is actually system level, and this is where you make it difficult for the hackers to actually know the offsets into your stack, where the return address is for your stack. You're actually randomizing. What's happening is you're randomizing the amount of space that's on the stack. People cannot tell where their actual return address is. Let's look at this specifically. And this is what we mean by this. You allocate a random amount of space so people don't know. What this does is it actually changes where the location of the return address is relative to your buffer, so people cannot necessarily tell where that is. I believe in the attack lab that's done, but it doesn't change. You don't have to worry. Once you figure out what that is, you don't have to worry about it changing again. Basically what this does is it makes it harder. It makes it more challenging. It's not impossible though to figure out where the return address is. Or where to insert code. The benefit of this is that it will reposition where the stack is and where the stack pointer is, so it's harder to do both of those things. That's address space layout randomization, but this is not impossible for a hacker to go over if they notice any pattern or if they happen to get lucky when they're figuring out where things are. We'll talk about more concrete ways. There's that randomizing stack offsets. This is a way. This is a better way to do it. One thing that you may have noticed, if you ever try to run some of the code that we have for this class not on the right machine on the incorrect Linux server, you'll notice that you'll fail when you're trying to do insert code, it won't run the code on the stack. That means that makes the stack non executable, so you cannot run the code. That's the other type of protection that's given system level, which just means that the stack is labeled as non executable. Even if you overwrite the stack with code and try to return to the code that you wrote, it won't run. That's when you make the stack itself non executable. Even if you successfully overwrote the buffer with exploit code and you successfully return to it to execute it, it won't be executed. That's what we mean by non executable code segments. That's one thing with the stack. I don't know if has anybody ever tried that yet. If you run it on a machine that you're not supposed to be running the lab on, you'll get this type of error. I just want to mention that if that's happening to you, you're not running on the correct machine. The machines that you have to run the attack lab have permissions to permit you to write the stack and let you do that. The third idea is this notion of a stack canary. And what a stack canary is, which we just put a special value on the stack right after the buffer. Then after you make your call to read into the buffer, check if it changed or not. That's all you need to do. Basically, the stack canary, you can think it's just a special value to check, did I overwrite this or not? You get it with the compiler with the F stack protector. This will prevent you from actually overwriting the buffer because when you return, the stack canary is not going to be the same, you will have changed it. That's the whole point of this. But let's see what this looks like in code. Let's see. This is the same echo code we had before, but now it actually has a stack canary. We'll take a moment just to look at what changed with the code now. Just give it a minute. What looks different now? Does anybody have ideas of what looks different now? Change. Sure. Yes, absolutely. That's awesome. This is a great observation. One observation if you didn't hear that was just made is like, wait, there's a stack fail that's getting called. A stack check fail getting called. That's important. It's actually checking, but what mechanism is it using to actually check that now? You'll notice that this code looks similar in that we allocate more memory on the stack frame, but then you'll notice that here. We're doing something interesting that we may not have seen before. What is this SFS? This FS is actually a register that you haven't seen before. These are called fragment registers. FS is a special fragment register. It's keeping track of thread control block. What you can think of this is it's going to that register, it's going to 28 in hex below it, getting a value, getting a special value, and writing it into Rx. It's getting a special value. What's 28 in hex in decimal? I just screaming out. What is it? What is it? 40, 40 bytes from Fs and writing it into rex that's the first thing it's doing. The next thing that it's doing, which is super useful is now it's taking that value and writing it onto the stack. The next instruction, the two is taking that special value that we just got. This is one and this is two and then write the special value onto the stack. That's the canary. That special value is the canary. It's writing that special value onto the stack beyond where the buffer is, is what it's doing. Then it lets do whatever it gets going to do and let's put do whatever it's going to do, and then you'll notice that it checks the value. Right here, it takes whatever value was on the stack at that address. Where the canary was put. It takes the value where the canary was put, puts it into RX That's what it does. It puts the value on the stack where the canary was put, which is just the stack pointer plus eight. What is the XOR doing? What it's doing now is it's checking if this line right here, what should the value be if it didn't change is the key insight. It should be zero because if you take the XOR of a value with itself, it's going to give you zero. Here it's in this line when it does the XOR check the value that I put on the stack. That's the value relative to the segment pointer. And then If it hasn't changed, then I know I can jump and just leave the function. But if it has changed, I'm going to say that there's a stack, that there's a failure because you overwrote the canaries. This step four is doing is compare The value on the stack now with the canary value with the real canary value, and if it's equal. Xor is only going to be equal equal to zero if it's the same value for that one. Let me just put this is zero if the same value. Okay. I sorry about that. This should be segment, sorry about that. That's what a canary is doing. You take a value, put it on the stack, let call gets or whatever you're using to manipulate the buffers. After they return, you check the value you put on the stack. If it's the value of the canary, then you know it wasn't overwritten. If they're different, if that value on the stack changed, then you know that somebody overwrote the buffer. That's what the canaries are doing. Okay. That's all we're doing. Just to recap, we place the canary value on the stack, and then we get it from the stack and check it if it's changed or not. You'll notice that in the echo function that we wrote, we actually made sure that we that we actually put the stack pointer plus eight, and then we put the canary. We have the buffer, a little bit of space, and then we have the canary, and that is what actually lets us check if we had overflowed the stack by putting that canary value there. Okay. That's the exact same difference. With the guess code, with any code, you just put the canary on the stack with those lines and then get the canary value from the stack, check it if it changed, and then if it did, then you know you overflowed the buffer. Okay. Questions. This is done by the compiler. This is not done by you and code, the compiler. These instructions that we're just highlighting, putting this on the stack, these are actually done by the compiler for you. This putting the canary values on the stack is done by the compiler. You don't have to do it. You just have to use the correct compiler flags. This flag is what we do this for you. It's done by default often and these instructions, when you look at it will be put and then that's what's actually going to be checked. I think we'll take a break, but let me just summarize what's happening now. A couple of things. Okay. These are ways to mitigate attacks with no program intervention. What can programmers do? Programmers cannot use values of Gs. Use the protected values, which is F gets would give a limit to the buffer. Anytime you're reading into a buffer, make sure you're actually checking the limit or calling libraries to check a limit. That's what programmers could do. What things that you do not have to do, the system can do is that you could have a randomized memory offset for the stack. That is not something you control. That's what the system controls. Here you cannot as easily guess where the code should be or where you should be writing into the stack or where the return address is why. It's because it's randomized. That's the randomization of address. Another very powerful thing is that you can have segments of the stack where you cannot execute code. You have parts of memory where you cannot execute code that's non executable code segments. For example, even if you wrote code onto the stack and you even had the correct return address to go to where you put the code on the stack, it will not be run because that segment will be called non executable. You'll get an error in that the code will not run, even if you did the attack correctly and if you're accidentally running an attack lab on the wrong machine, you'll get back. Then finally, the last part is compilers can place canaries on the stack for you. All a canary is is a special value that's put after the buffer on the stack, and then after whichever vulnerable potentially vulnerable code returns, The compiler adds instructions to check the canary value that was put on the stack. If it's not equal, you'll actually get an error. That's what happens with the canaries on the stack. It actually checks if it's not the same value, then you'll get an error. If it is, then it believes that you did not overwrite the buffer. That's what happens to that. Go ahead. Yeah, that's still a vulnerability. If you happen to know what the canary is, the question if you didn't hear it was, what happens if you happen to know what the canary is, then it wouldn't be a problem. Because the insight is, what if I wrote exploit code, I knew what the canary was, and then I just keep on, then that wouldn't be detected. Yeah. It's a specific value that'll be specific to the process that's being run. That's that's why it would be hard to guess what the canary was because it's specific to that thread being run. We'll talk more about that we're going to have a little bit of time when we talk more about operating system topics, so we'll talk a little bit more about that. Yeah. I think this is a good point for a breaker to ask questions. We'll start again at 3:00 and. There is. I have a question about the canary we just talked about. First of all, is it always as does the battery size of Yes. Aligning with the size of the Return address. Yes. Yes. So this could be not only eight or no. Usually sorry, let me turn this off. Usually the canary is an address. It's an Okay. Okay. All right. Now we're going to talk about a final set of attacks that actually addresses some of the protections that we had just mentioned, and they're called return oriented programming attacks, ROPs. You'll also be working on these on the attack lab. Some of the challenges that we just mentioned, which were introduced to actually make it difficult to launch attacks was that we could have stack randomization and as we mentioned, that makes it hard to predict where the buffers were going to be to start overriding the buffers, to have an overflow attack. The other concern was that we could have non executable sections, which even if you're successful in overwriting the buffer, you inject your code and you actually write the correct return address, you would not be able to run the code because the code on the stack is non executable. Here, we're looking for a different strategy to come around these and that strategies is, what if there's a way for us to run existing code? To string together the locations of existing code in order to launch an attack. That's exactly what ROP attacks are. We're able to actually run the code because the code itself, the addresses for the code is going to be the same at different executions of the code and the code is executable. The point of the return oriented programming attacks, ROPs is that rather than trying to inject my own code, I'm going to see if I could string together attacks using existing code and all I have to do at that point is just overwrite the return addresses to call the existing code. That code is going to be executable because it's just code, it's not code that I wrote on the stack, and all I need to do is figure out the addresses to do that and overwrite the return address. That's how we can circumvent some of the protections that we had just talked about is think about, let me exploit existing code, string those return addresses together to launch my own attack. Let's think about it. How can we actually use overwriting addresses to call a sequence of functions by overflow? Here, we want to execute function one at return address A and then function two at return address B, and then function three at return address C? How can we actually do this with the buffer overflow attack? Any ideas? How can we do this with a buffer overflow attack? Now I have these functions. I know what their addresses are, but I want to figure out how to string together how to call them. How can we do this? Sure. We want to call them by order. That's a good insight. We definitely want to call them by order. The trick is we want to basically just write the return addresses to be stacked on top of each other on the stack. That's essentially what to do. Then what are we exploiting when we do this? What does return do? Here we're taking advantage return queue is always going to take the address at the top of the stack, put it to the instruction pointer, and then start running the code. As long as the code segments that you're stringing together have a return, it's going to keep on executing everything that you have, the return addresses that you put on the stack is what's going to happen. Let's see what this looks like. Each function, when it finishes, is going to return to the address that you put on the stack to be the beginning of the next function that you want to run. If you want to run F one first, you put that at the top of the stack, that's return address A. Then if you want function one to return and then execute function two, you put the return address for function two on top of that and so forth. What we're doing here is you're stringing together using the return addresses, stacking them on top of each other in the order that you want the functions executed. That's what we're doing for this. If you want function one, So function one is recalled. Then what return will do, then return queue will pop the address of function two into the instruction pointer and continue and so forth. That is the mechanism that we do this. As long as we overwrite the return addresses in the order in which we want the code executed, that's how it's actually going to work. But what's the one thing we have to be careful about now? There's actually two things. We understand we have to overwrite the return addresses in the order from the first up to the last we want to execute, but what is the property of all the code we have to call now in order to exploit? Sure. It has to use return queue. This is the key idea. Any code that we call must include the return queue. That is the critical idea and why it's called return oriented attacks. Because you're exploiting the fact that return queue is always going to take the instruction at the top of the stack, put it into the instruction pointer, and then execute from there. That's why they're called return oriented attacks, is that it's exploiting that return queue is just going to take the address at the top of the stack, put it in the instruction pointer and start running whatever code you have there. That's the critical idea with the return oriented attack. Okay. Questions about this. We talked about the abstract idea. We want to string together these return addresses. We know return queue as long as we put the right addresses is going to call them. How do we find these instructions that we want to put together is the question. How do you actually find these? It could be a whole function you want to call and that would be fine. You just put the function that we want to call, that's fine. But maybe you don't have a function that does exactly what you want. How do you find it then? It's possible there's a set of functions, function one, function two, cool. You just put their addresses and you could read that in the code where those addresses are, and it's not going to change. That's the other benefit where these types of attack are not vulnerable to stack randomization because the code is going to have the same address like this function is at this address. This is some of what you exploit in GDP, for example, you set the debugger at this function and you just go ahead and look at it. But here we're asking a different question. How do you know if you don't have a function that does everything that you want, how do you actually make it do that? Anyone have ideas or look at attack lab? No. It's gadget. What a gadget is is the ending of functions. The reason why we include the ending of functions is because it has the return. That machine instruction is the C three. The return code is the C three instruction, and that is what's going to make sure that you actually go to get the return address from the top of the stack to be in the instruction pointer to continue your attack. Let's see what this looks like. And these are called gadgets. They're snippets of code. This isn't the entire function. We just take a part of the function that does what we want and we set the return address to this instruction. Here we have this function which we are going to abuse, meaning that we are taking A times B plus C and returning it. This is what our function, long AB plus C is actually doing. But you'll notice that we just want an instruction that is going to take Rd plus rdx and put that into Rx. That's what we want. What we can do is we can set up a gadget which just has that instruction, which is putting Rd plus rdx into Rx and it includes the return. That's the important idea. Two important things. What we wanted to do is this. We need an instruction that can do this. The other important thing for any gadget that you construct, it has to include the return, must include the return. But the key thing then what we want to do is we want to write the address of this gadget as the return address. Because what happens is once that return address, in this case, 400 is put into the instruction pointer, it is going to start running that instruction until it gets to the return. When it does that, it will load RDI plus Rx into Rx and then return. We'll have the effect that we want. Basically, this will execute that instruction and return to get the next address at the top of the stack, the return address. That's what's going to be happening. When you're looking at the attack lab, did anybody look at the form yet? The whole idea is you look in the farm to see, is there any existing machine code that does what I want, including that return code, C three, and I will point to start at that address where that is starting happening. That's how the return oriented attack you go to your form of code, you find instructions you want and you start putting the address of those instructions as the return addresses that when you overwrite the buffer. We're going to do a concrete example of this in just a minute when we start looking at the code. I want to give another example. This is a nice example because this has an instruction doing exactly what we want to do, and then we return. But we can even be more clever in that you don't have to start at the beginning of an instruction. Here's what I mean by this. Here, we want an instruction that is going to move Rx into RDI. Suppose we want to load an argument that we want for a subsequent call. Here, you don't even have to go to the start of the instruction. Here you can actually go inside the middle of the instruction. What is important here is we have this set value, we are going to set whatever is being pointed at at P to this, this unsigned value and we look inside of that value, that unsigned value, and we find the machine code for the instruction that we want. That instruction is we want to move Rx to RDI. That is the machine code. In the attack lab and I don't expect you to know the memorize these at all, you'll always have examples of machine code. The machine code for move queue RX RDI is 48 89 C seven, and so we want to start at that instruction and you'll notice that right after that, we have the C three. The only thing that we need to do is figure out the address for the start of this gadget. Why is it 4004 DC? Why is the start of the gadget that? Sure. Exactly. Where we get this from, the actual instruction in the set valve function is, sorry about that. It's 4004, but you'll notice that we have to move over three bytes inside that instruction is where we actually want the code to be executed from. That's why you can actually take you can take existing functions and use their code in a way that wasn't intended. This is another benefit of these types of attacks. So when you're looking at your farm, you don't have to use entire instructions. You can go inside the machine code for an instruction and start at the byte that you want and then have the code executed from there. That's what this is another example of. But once again, we just have to make sure that the critical part is that we have this return seek included because the code is going to be executed from the address you give it to the return instruction, the C three instruction. Questions about this. All right. This is exactly what we're talking about. The way that the return oriented attacks work is now rather than putting addresses for functions, you put the addresses for your gadgets, the code that you want to run, you put the first gadget as the first address, the address of the second the gadget above it all the way up to the th gadget that you want to run and you put them on top in the sequence from the first going up the stack to the end one. Okay. The first gadget is what's actually going to start this off. The first gadget is going to include return queue, which is C three machine code. That's going to trigger the next gadgets address to be read into the instruction pointer. That will include a return queue and so forth. That's how this is actually, and this is why they're called return oriented programming attacks. Okay. Okay. Questions about this so far, and how you're going to be stringing them together for the attack lab. So far so good. Now is your chance to get to work. We're going to work on some different attacks now and you'll be able to work in groups on this. I have a very detailed attack lab exercise where we're going to get at this together. I don't know if you can see this code. Let's take a moment and you can talk about this code with the person next to you. We'll give it just a few minutes to take a look at this code and then we'll start talking about what potential attacks that you can do. I'm also going to be looking at your questions right now. And to the right of this, if you have the notes, I have a stack diagram which is which we're going to be filling in. Oh, this is a good question. Oh, I have to switch out my batteries. I'll answer in a second. Hold on. Okay. Has everyone had a chance to look at the code? Ready to talk about it? Okay. Ready to talk. One question and a great question that was asked on Slido is, how do we actually get the gadgets onto the stack is the question. Someone asked, how do we get gadgets onto the stack? Sure. A couple of key observations and I'll repeat the answer that was just given. The first thing is, some of what return oriented programming attacks using gadgets to do is that you're not actually writing the code on the stack. You're using existing code. That's one thing. One, you know the addresses of the existing code and you don't actually write the code of the gadget onto the stack. What you write onto the stack is the address of the gadget, the existing code. You have to write the address of the gadget starting at the return address. You put your first gadget where the return address was and any subsequent gadgets above that in the order in which you want them called. You basically take the start of the buffer, the overwrite the existing return address with the address of your first gadget and then your second and so forth. The way that you're putting the gadgets on the stack is you're only putting the address of where the gadget is located, not the actual gadget of the stack. You're just putting the address of where it is in existing code. That's the important idea with gadgets. Okay, let's take a look at this code now. Who can help us out? What's happening in this code, say the first two lines and then I'm going to make it smaller and start writing in what's happening on the stack. What are we doing, the first thing that we're doing? Yes, we're making room for the stack. The first thing that we're doing and by the way, in this diagram, each row is eight bytes. I'm going to make this a little bit here so I don't mind because the extra column is just for extra notes. The first thing that we're going to do and you'll notice that these addresses are all in hex. Where should the stack pointer be after that very first line? Yes. It's starting right here and this is where it is. The technically it would be right here. The right edge is the lower address. Where's the stack pointer going to be after that subtract line. This also tells us where the buffer is going to be. This was my RSP. What value is going to be my new RSP? Here's my new RSP. After that one line is going to be right there. Let me just highlight that for you. After this line, our new RSP is going to be right here. We subtracted 38 off of the stack right there. 38 in hex, by the way, 38 hex. The next thing that we're going to do is we're going to take this value before, and we're going to write it onto the stack at 28 relative to the stack pointer. Where should I be writing this value before? I think eyes ideas. Where should we be writing this value? Sure. The address is going to be 48. I'm just going to highlight so we can see which line in the code. Then I'm just going to write this and it's a long, so it's eight bytes. I'm going to put B, four, and then all zeros. I'm writing everything in hex. I'm just writing every heck which is why it's two characters for each byte. Okay. Where should after be in the sack? We're at the third line in assembly now. Yeah, let me put this in for you. Here we're going to put at 23. Actually, it's going to be eight. I'm going to put this right here. Yeah. I just took care of that. I just did the first two lines and those are basically the initialization. Then now we're getting into the buffer. Where is the buffer going to be? What address should the buffer be at? It says the buffer in this instruction, it is going to take the stack pointer and add 16 to it, which is 10 in hex, and that's where we're going to actually have our buffer, which is going to be right here. This is our buffer. All righty. All right. So let me just highlight that. Okay. Okay. This is the buffer, this address, the one that I just highlight, I'll just highlight this entire address. You'll notice that that address is what's getting put into RDI for when gets gets called. Whatever gets is writing is going to start writing right there. That's what's happening in this attack. Then we call gets. What happens if what we input is one, two, three, four, five, six, seven, eight, and ASCI is the question. What's going to be placed into the buffer Similar to what we saw in a different exercise. Anybody know? Sure. Exactly. You'll notice that I'm going to start here because this will be the start. This will be 31, 32, 33, 34, 35, 36, 37, and 38. We just gave an example of what happens if we call gets and that's what we're doing. We just fill the buffer. No overflow or anything is so far so good. Well, let me see if we overflow? No, we didn't do any overflow or anything yet. Buffer and. Yeah, let's do that. Then we have to go to the next one and we're going to put zero. We're good. But we haven't overflowed the buffer yet because we just wrote nine characters. How much space do we have till we overflow the buffer is the question. Meaning that we start overwriting the return address? How much? 15 the buffer would end. I guess the question is, you're saying 15? 16. Where is the buffer, by the way? How big is the buffer, just to refresh your memory. It's 16 bytes. Here is right here. I just want to highlight that the buffer is 16 bytes right there. This is still the buffer. The buffer is 16 and we're just curious about how do we know what we're going to overflow the buffer and start writing into the return address is the question. Yeah. We actually have to go 24 more bytes until we start overwriting the return address. I just want to make this observation. You'll notice that there are 24 bytes after the buffer before the return address. This is where I'm talking about right here right there is the return address. The end of the buffer is the yellow that I just highlighted, just so we know that we're doing. So far, we're just put the before and after value. We saw what it looks like if someone behaves nicely and gives us a nice string and go ahead. After the buffer. After the buffer. After the end of the buffer, we have those three rows. I'll highlight those. I'll highlight those in blue for you so you see what I mean. The rows. This is the start of the return address. So far we saw how this works. We know we have two values on the stack already and now we have a buffer. Now it's your turn. If we call the function win, which is at 4006 EE, with the correct value, we'll win a cookie. How do we do this? Take a moment to talk to the person next to you because now we want to overwrite the buffer to make sure that we have the right value so that we can win a cookie. That's the question. Let's take a minute to talk to the person next to you. Basically, we want to make sure that we have the right value In before where before is written, in order to get a cookie is the point. Right now, I just want to point out before is right there. This is what we're looking at right now. We're trying to change this so we can win a cookie. How do you do that? Sure. Which numbers? Do you mean the ones, the ones for before? Oh, I see. I see. Yeah. Okay. Which numbers? One suggestion that was made was we would put we would actually have to write the numbers 15213. Is that what we want to do? We'd have to put that in RDI. It's a good idea. The key observation that was just made is if we put that value in RDI, we would win the cookie. But could we get that value in RDI by writing the stack is a question? What are we going to be looking at? What number is it that we're concerned about having? Let's take a look let me just take a look at the code because that will help us when we're thinking about how do we win a cookie. We call gets, which means that by the time we're worrying about getting our cookie, we've already overwritten the buffer. Now we're in the second section. What we're going to do is take whatever value is at the RSP plus 28 in hex, which is just going to be 40. We're going to take that value and put it in RDX. Then we're going to put that value, this immediate which is in the IF statement into Rx and compare what we got off the stack with the immediate value. If they are not equal, we're just going to jump to 40 06f3. If they are equal, we're going to put the value that we want into the EDI was suggested and call Q. The good suggestion was made, the good observation was made is that when we're at Eruion 40 06e9, we want this value 15213 in hex to be an RDI. But can we do that with the buffer overflow attack directly? Good. Exactly. Here, this is the key observation. We want this value on EDI, but just writing that to the stack will not put it in EDI. What we control is we can control the value, which is at the stack pointer plus 40. We put the value we want there because it's going to be moved from the stack to RDX and then it's going to be compared to the value. Let's see how we can actually do that now. Our goal, let's talk about this. Just to explain what we want to do, we figured out this attack. Our goal is to get the correct immediate value onto the stack where before is. At RSP plus 40. That's our strategy because we can see that when we do that at instruction 40 06d5, it's going to move the value that we wrote onto the stack into RDX and then compare it to the immediate loaded into RX. That's our goal and this is the immediate value that we want. The immediate value that we want is this value. We want to make sure we put this onto the stack. Read it back, and then when we get to this next instruction, comparing that immediate with the value we wrote on the stack, we're going to be able to win the cookie, it'll call win. Is everybody clear about the strategy, what we're trying to do? Yes, so far so good. Just the throat vote. One, yes, two, I'm not sure. Throat vote, can I see? I get what's going on. Two, I'm not sure. No one can see but me. Throw vote. One, two, one is yes, two, I need more clarification. It's good. It's looking pretty good. We have the goal and here is what we're actually going to do. For example, in the attack lab, you're going to have a file that you write in hexter. This is an example of one of those such files. You'll notice that I have some padding and why do I have those bytes of padding? I have 24 bytes of padding. Why is that? Why? Because we want to make sure that we start writing this relative to where the buffer is to where before is at. Let's see what this looks like when we actually put this in. I just want to just to refresh our memory, RSP is right here. Our buffer is right here. When you call gets, gets will start writing at the start of your buffer. What's going to happen with this is it's going to start writing the values, all of the zeros. This is important when you're actually working on the attack lab because this is what we are talking about with padding. These are just you could put whatever values that you want, but the whole point of it is you want to get to the location. We have this and you'll notice now we've overwritten the buffer and now we're where before is at. What is important about the way that we're writing from the file onto the buffer in representing this immediate value is the Indianness. That's the important thing. How can I actually write this to actually make sure that the Indianness is correct? Yeah. Starting with little Indian, the smallest is going to be the smallest by is going to be 31, and then 35, 32, 31, 33. That is actually how we're keeping track of the Indianness too. You'll notice that when you're entering things into Hefura, you want to make sure that you are entering it so that the Indianness will be respected too. Sure. I don't think you absolutely need the zeros. I don't think you have to. Let me just double check. It's a long. It's okay. You don't absolutely, but I put them there. Now, what we've done is now after gets, we would be in the instruction. Go ahead. No. But the reason why I mentioned this is that when you actually make the file that you're piping, when you enter it in the file, you want the chars to be written so that the representation is in Little Indian. Does that make sense? The question was, these are just chars. Why are you worried about Indianness? The reason why is that if inside your file that you're piping for Hexaw to the attack lab, if instead you did this, You would have you wouldn't have the right number when it's interpreted as the stack. Yes. When it gets read off the stack, it's going to be interpreted as an integer. That is why it's important to respect the Indianness when you're writing it onto the stack and writing it onto the file. That's the reason. Not be correct Little Indian. Even though each byte is being written when it's interpreted from the stack, it will be interpreted correctly. That's why we wrote it that way. Other questions? Sure. It doesn't necessarily matter. I tend to put zero. If there's values that we don't care about, I've been tending to put zeros. Other questions with this example. We just did a buffer overflow attack. We overwrote the buffer to then take control over what we wanted the execution to do. Go ahead. In the attack lab, what you'll do you look at the instructions for a Hera and then it will be piped to the program. But you put this in a file. This is the exact format that you'll use for those files that you use for Hextra. Yeah. Questions about this. We just want a cookie by doing a buffer overflow attack, we put the value that we wanted to be right off of the stack into the buffer, and then we would win a cookie. Things are getting more complicated. How do you win two cookies? How would you win two cookies now? What type of attack do we need for this? There's a couple of ways we can do this. I'll give a little bit of what we can do. Sure. The right. One good idea is we could do what we did before and then we want to return address. We want to overwrite the return address to be right here. We want to make sure that we overwrite the return address to then give us our second cookie. Basically, do what we just did and then rewrite the return address to give us this additional cookie. That's one idea that we can do. Basically, in the attack we just did, What's the problem with that? There's a problem with it though. What I mean is this would then get changed to hit this and we'd have the rest of the things we did. But there's something wrong with this attack that's a little bit subtle. Go ahead. There is actually return afterward. There is a return afterward right here. What will happen and this is important when you modify the return address, it's going to run any instructions until it hits the return queue again. What we're doing in this attack that I want you to think about is we're modifying the stack pointer. We probably won't have time to finish because we're almost out of time. Another attack that we can do that we'll finish up on Tuesday is code injection. How could we actually use code injection to help us win our second cookie is the task now. We'll pick up with this next time, but it's a concrete example of how can we use code? Basically, what we want to do with code injection is we want to write what we want the code to do onto the buffer and then return to the start of the buffer. Code injection attack. That's what we'll look at next time. Awesome. Thanks everyone. Thank you.